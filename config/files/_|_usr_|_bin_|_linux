#!/usr/bin/env python2
"""
Description:
    Personal linux interface.

Usage:
    linux dic play <voice>
    linux sd compile audiobooks <dest>
    linux mp3 save <path>
    linux drive update

Options:
    -h --help   Extensive help message.
"""

from os import path, walk, listdir, environ, getcwd, makedirs
from subprocess import Popen, PIPE, CalledProcessError
from docopt import docopt

import json
import re
import fnmatch
import shutil
import sys


# sys.exit codes: http://stackoverflow.com/questions/1101957/are-there-any-standard-exit-status-codes-in-linux


class Shell(object):
    @staticmethod
    def _parseCmd(cmd):
        if isinstance(cmd, basestring):
            return cmd.split()
        return cmd

    @staticmethod
    def _calledProcessError(cmd, err):
        raise CalledProcessError(1, ' '.join(Shell._parseCmd(cmd)), output=err)

    @staticmethod
    def cmdWait(cmd, catchErr=False, output=False, workingDir=None):

        output, err = Shell.cmd(cmd, output=output, workingDir=workingDir).communicate()

        if not catchErr and err != '':
            Shell._calledProcessError(cmd, err)

        if catchErr:
            return err
        else:
            return output

    @staticmethod
    def cmd(cmd, output=False, workingDir=None):

        stdout = None if output else PIPE
        stderr = None if output else PIPE

        return Popen(Shell._parseCmd(cmd), stdout=stdout, stderr=stderr, cwd=workingDir)


class Utils(object):
    @staticmethod
    def openImage(*paths):
        return Shell.cmd(['eog', path.join(*paths)])

    @staticmethod
    def openAudioPlayer(*paths):
        Shell.cmdWait(['vlc', path.join(*paths)], catchErr=True)


class Fs(object):
    @staticmethod
    def findFiles(dir, glob):
        print(' > Searching for "{}" in "{}"'.format(glob, dir))
        matches = []
        for root, dirnames, filenames in walk(dir):
            for filename in fnmatch.filter(filenames, glob):
                matches.append(path.join(root, filename))

        if len(matches) == 0:
            print(' ! No file found')

        return matches

    @staticmethod
    def mvToTrash(*paths):
        print(' > Move to trash: "{}"'.format(path.join(*paths)))
        Shell.cmdWait(['sudo', 'gvfs-trash', path.join(*paths)])

    @staticmethod
    def getCwd(*paths):
        return path.join(
            getcwd(),
            *paths
        )

    @staticmethod
    def setFilePermissions(*paths):
        Shell.cmdWait(['sudo', 'chmod', '775', path.join(*paths)])


class GDrive(object):
    @staticmethod
    def getPath(*paths):
        return path.join('/home', environ.get("USER"), 'gdrive', *paths)

    @staticmethod
    def update():
        print(' > Updating drive')
        Shell.cmdWait('grive --progress-bar', catchErr=True, output=True, workingDir=GDrive.getPath())

    @staticmethod
    def saveEmotion(*src):
        emotion = raw_input(' ? Custvo: ')
        destPath = GDrive.getPath('custva', emotion, path.basename(*src))

        # Create new emotion if not exist
        if not (emotion in listdir(GDrive.getPath('custva'))):
            if 'y' == raw_input(' ? mkdir "{}" (y/n):'.format(destPath)):
                makedirs(destPath)

        # Copy to emotion folder
        print(' > Emotion saved: "{}"'.format(destPath))
        shutil.copyfile(path.join(*src), destPath)

    @staticmethod
    def saveAudioBook(*src):
        destPath = GDrive.getPath('knjige/audio', path.basename(*src))
        print(' > Audiobook saved: "{}"'.format(destPath))
        shutil.copyfile(path.join(*src), destPath)


class AAX(object):
    def __init__(self, *file):
        self.path = path.join(*file)

        meta = Shell.cmdWait(['ffprobe', self.path], catchErr=True)
        self.author = re.findall('artist\s*:\s*(.*)', meta)[0]
        self.title = re.sub('\s*\(\s*Unabridged\s*\)\s*', '', re.findall('title\s*:\s*(.*)', meta)[0])
        self.bitrate = re.findall('bitrate:\s*(.*)\s*kb', meta)[0]

    def getOutputFile(self, fileExt=None):
        if fileExt:
            fileExt = '.{}'.format(fileExt)

        return re.sub(r'[\\/:"*?<>|]+', "", '{} - {}{}'.format(
            self.author, self.title, fileExt
        ))

    def to_mp3(self):
        compiledFileBase = self.getOutputFile(fileExt='mp3')
        compiledPath = Fs.getCwd(compiledFileBase)

        print(' > Compile "{}" to "{}"'.format(self.path, compiledPath))
        cmdArr = 'ffmpeg -v error -stats -activation_bytes 0cedab08 -i {input} -vn -c:a libmp3lame -ab {bitrate}'.format(
            input=self.path,
            bitrate=self.bitrate
        ).split()
        cmdArr.append(compiledFileBase)
        Shell.cmdWait(cmdArr, output=True, catchErr=True)

        Fs.setFilePermissions(compiledPath)

        return compiledFileBase


class Device(object):
    def __init__(self, uuid, alias):
        self.uuid = uuid
        self.alias = alias
        self.mountPath = path.join('/media', environ.get("USER"), self.alias)
        self.devicePath = None

        self._setDevicePath()
        self.mount()

    def getMountPath(self, *paths):
        return path.join(self.mountPath, path.join(*paths))

    def _setDevicePath(self):
        lsblk = json.loads(
            Shell.cmdWait('lsblk -f -J')
        )

        for blockdevice in lsblk['blockdevices']:

            devices = [blockdevice]
            if 'children' in blockdevice:
                devices += blockdevice['children']

            for device in devices:
                if self.uuid == device['uuid']:
                    self.devicePath = path.join('/dev', device['name'])

        if not self.devicePath:
            print(' ! Device "{}" not found'.format(self.alias))
            sys.exit(68)

    def mount(self):
        print(' > Mount: "{}" to "{}"'.format(self.devicePath, self.mountPath))
        if not path.exists(self.mountPath):
            makedirs(self.mountPath)
        Shell.cmdWait(['sudo', 'mount', self.devicePath, self.mountPath], catchErr=True)

    def unmount(self):
        print(' > UnMount: "{}"'.format(self.mountPath))
        Shell.cmdWait(['sudo', 'unmount', self.devicePath, self.mountPath], catchErr=True)


class Dictaphone(Device):
    uuid = "0000-006F"
    alias = 'dictaphone'

    def __init__(self):
        super(Dictaphone, self).__init__(self.uuid, self.alias)

        self.emotions = 'A'
        self.todos = 'B'
        self.book = 'C'
        self.other = 'D'

    def getVoicePath(self, *voice):
        return self.getMountPath('VOICE', *voice)


class Mp3Player(Device):
    uuid = '846D-FD0B'
    alias = 'mp3Player'

    def __init__(self):
        super(Mp3Player, self).__init__(self.uuid, self.alias)

    def getMusicPath(self, *paths):
        return self.getMountPath('MUSIC', *paths)

    def saveMusic(self, *src):
        destPath = self.getMusicPath(path.basename(*src))
        print(' > MP3 saved: {}'.format(destPath))

        Shell.cmdWait(['sudo', 'cp', path.join(*src), destPath])


class SdCard(Device):
    uuid = '5C6B-303E'
    alias = 'sdCard'

    def __init__(self):
        super(SdCard, self).__init__(self.uuid, self.alias)


if __name__ == '__main__':
    args = docopt(__doc__)

    if args['dic']:

        dic = Dictaphone()

        if args['play']:

            # Save voice
            voice = args['<voice>']

            # Get voices files.
            voices = listdir(dic.getVoicePath(voice))

            if len(voices) != 0:

                # Open image
                imageProcess = None
                if voice == dic.emotions:
                    imageProcess = Utils.openImage(
                        GDrive.getPath('custva', 'emotions.jpg')
                    )

                # Process every file in voices
                for file in voices:
                    print(' > {}'.format(file))

                    voiceFilePath = dic.getVoicePath(voice, file)

                    # Open audio player with file
                    Utils.openAudioPlayer(voiceFilePath)

                    # Process emotional voices
                    if voice == dic.emotions and 'y' == raw_input(' ? Upload file (y/n):'):
                        GDrive.saveEmotion(voiceFilePath)

                    # Move to trash if user wants it
                    if 'y' == raw_input(' ? Trash file (y/n):'):
                        Fs.mvToTrash(voiceFilePath)

                # Close image viewer
                if imageProcess:
                    imageProcess.terminate()

                # Update drive
                if 'y' == raw_input(' ? Update drive (y/n):'):
                    GDrive.update()

            # Warn on no file
            else:
                print(' ! No file in "{}"'.format(voice))

        dic.unmount()

    elif args['sd']:

        sdCard = SdCard()

        if args['compile']:
            if args['audiobooks']:

                dest = args['<dest>']

                # Check dir existance
                if path.isFile(dest):
                    print(' ! Is not dir: {}'.format(dest))
                    sys.exit(64)
                if not path.exists(dest):
                    makedirs(dest)

                # Get glob files .aax
                aaxFiles = Fs.findFiles(
                    sdCard.mountPath, '*.aax'
                )

                # Process every aax file
                for aaxFile in aaxFiles:

                    aax = AAX(aaxFile)

                    if 'y' == raw_input(' ? Process "{}: {}" (y/n):'.format(aax.author, aax.title)):
                        mp3File = aax.to_mp3()
                        shutil.move(mp3File, path.join(dest, mp3File))

        sdCard.unmount()

    elif args['drive']:
        if args['update']:
            GDrive.update()

    elif args['mp3']:
        mp3Player = Mp3Player()
        if args['save']:
            mp3Player.saveMusic(args['<path>'])
        mp3Player.unmount()
