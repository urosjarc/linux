#!/usr/bin/env python2
"""
Description:
    Personal gadget interface.

Usage:
    gadget dic play <voice>
    gadget mp3 load audiobook
    gadget drive update

Options:
    -h --help   Extensive help message.
"""

from subprocess import Popen, PIPE, CalledProcessError
from docopt import docopt
from os.path import join as pathJoin
from os.path import basename

import os
import json
import re
import fnmatch
import shutil
import sys


# sys.exit codes: http://stackoverflow.com/questions/1101957/are-there-any-standard-exit-status-codes-in-linux


class Shell(object):
    @staticmethod
    def _parseCmd(cmd):
        if isinstance(cmd, basestring):
            return cmd.split()
        return cmd

    @staticmethod
    def _calledProcessError(cmd, err):
        raise CalledProcessError(1, ' '.join(Shell._parseCmd(cmd)), output=err)

    @staticmethod
    def cmdWait(cmd, catchErr=False, output=False, workingDir=None):

        output, err = Shell.cmd(cmd, output=output, workingDir=workingDir).communicate()

        if not catchErr and err != '':
            Shell._calledProcessError(cmd, err)

        if catchErr:
            return err
        else:
            return output

    @staticmethod
    def cmd(cmd, output=False, workingDir=None):

        stdout = None if output else PIPE
        stderr = None if output else PIPE

        return Popen(Shell._parseCmd(cmd), stdout=stdout, stderr=stderr, cwd=workingDir)


class Utils(object):
    @staticmethod
    def openImage(*path):
        return Shell.cmd(
            'eog {}'.format(pathJoin(*path))
        )

    @staticmethod
    def openAudioPlayer(*path):
        Shell.cmdWait('vlc {}'.format(pathJoin(*path)), catchErr=True)


class Fs(object):
    @staticmethod
    def findFiles(dir, glob):
        print(' > Searching for "{}" in "{}"'.format(glob, dir))
        matches = []
        for root, dirnames, filenames in os.walk(dir):
            for filename in fnmatch.filter(filenames, glob):
                matches.append(pathJoin(root, filename))
        return matches

    @staticmethod
    def mvToTrash(*path):
        print(' > Move to trash: "{}"'.format(pathJoin(*path)))
        Shell.cmdWait('sudo gvfs-trash {}'.format(pathJoin(*path)))

    @staticmethod
    def getCwd(*path):
        return pathJoin(
            os.getcwd(),
            *path
        )


class GDrive(object):
    @staticmethod
    def getPath(*path):
        return pathJoin('/home', os.environ.get("USER"), 'gdrive', *path)

    @staticmethod
    def update():
        print(' > Updating drive')
        Shell.cmdWait('grive --progress-bar', catchErr=True, output=True, workingDir=GDrive.getPath())

    @staticmethod
    def saveEmotion(*src):
        emotion = raw_input(' ? Custvo: ')
        destPath = GDrive.getPath('custva', emotion, basename(*src))

        # Create new emotion if not exist
        if not (emotion in os.listdir(GDrive.getPath('custva'))):
            if 'y' == raw_input(' ? mkdir "{}" (y/n):'.format(destPath)):
                os.makedirs(destPath)

        # Copy to emotion folder
        print(' > Emotion saved: "{}"'.format(destPath))
        shutil.copyfile(pathJoin(*src), destPath)

    @staticmethod
    def saveAudioBook(*src):
        destPath = GDrive.getPath('knjige/audio', basename(*src))
        print(' > Audiobook saved: "{}"'.format(destPath))
        shutil.copyfile(pathJoin(*src), destPath)


class AAX(object):
    def __init__(self, *file):
        self.path = pathJoin(*file)

        meta = Shell.cmdWait('ffprobe {}'.format(self.path), catchErr=True)
        self.author = re.findall('artist\s*:\s*(.*)', meta)[0]
        self.title = re.sub('\s*\(\s*Unabridged\s*\)\s*', '', re.findall('title\s*:\s*(.*)', meta)[0])
        self.bitrate = re.findall('bitrate:\s*(.*)\s*kb', meta)[0]

    def getOutputFile(self, fileExt=None):
        if fileExt:
            fileExt = '.{}'.format(fileExt)

        return re.sub(r'[\\/:"*?<>|]+', "", '{} - {}{}'.format(
            self.author, self.title, fileExt
        ))

    def to_mp3(self, *dest):
        dest = pathJoin(*dest)
        compiledFileBase = self.getOutputFile(fileExt='mp3')
        compiledPath = pathJoin(os.getcwd(), compiledFileBase)

        print(' > Compile "{}" to "{}"'.format(self.path, dest))
        cmdArr = 'sudo ffmpeg -v error -stats -activation_bytes 0cedab08 -i {input} -vn -c:a libmp3lame -ab {bitrate}'.format(
            input=self.path,
            bitrate=self.bitrate
        ).split()
        cmdArr.append(compiledFileBase)
        Shell.cmdWait(cmdArr, output=True, catchErr=True)

        shutil.move(compiledPath, dest)


class Device(object):
    def __init__(self, uuid, alias):
        self.uuid = uuid
        self.alias = alias
        self.mountPath = pathJoin('/media', os.environ.get("USER"), self.alias)
        self.devicePath = None

        self._setDevicePath()
        self.mount()

    def getMountPath(self, *path):
        return pathJoin(self.mountPath, pathJoin(*path))

    def _setDevicePath(self):
        lsblk = json.loads(
            Shell.cmdWait('lsblk -f -J')
        )

        for blockdevice in lsblk['blockdevices']:

            devices = [blockdevice]
            if 'children' in blockdevice:
                devices += blockdevice['children']

            for device in devices:
                if self.uuid == device['uuid']:
                    self.devicePath = pathJoin('/dev', device['name'])

        if not self.devicePath:
            print(' ! Device "{}" not found'.format(self.alias))
            sys.exit(68)

    def mount(self):
        print(' > Mount: "{}" to "{}"'.format(self.devicePath, self.mountPath))
        if not os.path.exists(self.mountPath):
            os.makedirs(self.mountPath)
        Shell.cmdWait('sudo mount {} {}'.format(self.devicePath, self.mountPath), catchErr=True)

    def unmount(self):
        print(' > UnMount: "{}"'.format(self.mountPath))
        Shell.cmdWait('sudo unmount {} {}'.format(self.devicePath, self.mountPath), catchErr=True)


class Dictaphone(Device):
    uuid = "0000-006F"
    alias = 'dictaphone'

    def __init__(self):
        super(Dictaphone, self).__init__(Dictaphone.uuid, Dictaphone.alias)

        self.emotions = 'A'
        self.todos = 'B'
        self.book = 'C'
        self.other = 'D'

    def getVoicePath(self, *voice):
        return self.getMountPath('VOICE', *voice)


class Mp3Player(Device):
    uuid = '846D-FD0B'
    alias = 'mp3Player'

    def __init__(self):
        super(Mp3Player, self).__init__(Mp3Player.uuid, Mp3Player.alias)

    def getMusicPath(self, *path):
        return self.getMountPath('MUSIC', *path)

    def saveMusic(self, *src):
        destPath = self.getMusicPath(basename(*src))
        print(' > MP3 saved: {}'.format(destPath))
        shutil.copyfile(
            pathJoin(*src),
            destPath
        )


class SdCard(Device):
    uuid = '5C6B-303E'
    alias = 'sdCard'

    def __init__(self):
        super(SdCard, self).__init__(SdCard.uuid, SdCard.alias)


if __name__ == '__main__':
    args = docopt(__doc__)

    if args['dic']:

        dic = Dictaphone()

        if args['play']:

            # Save voice
            voice = args['<voice>']

            # Get voices files.
            voices = os.listdir(dic.getVoicePath(voice))

            if len(voices) != 0:

                # Open image
                imageProcess = None
                if voice == dic.emotions:
                    imageProcess = Utils.openImage(
                        GDrive.getPath('custva', 'emotions.jpg')
                    )

                # Process every file in voices
                for file in voices:
                    print(' > {}'.format(file))

                    voiceFilePath = dic.getVoicePath(voice, file)

                    # Open audio player with file
                    Utils.openAudioPlayer(voiceFilePath)

                    # Process emotional voices
                    if voice == dic.emotions and 'y' == raw_input(' ? Upload file (y/n):'):
                        GDrive.saveEmotion(voiceFilePath)

                    # Move to trash if user wants it
                    if 'y' == raw_input(' ? Trash file (y/n):'):
                        Fs.mvToTrash(voiceFilePath)

                # Close image viewer
                if imageProcess:
                    imageProcess.terminate()

                # Update drive
                if 'y' == raw_input(' ? Update drive (y/n):'):
                    GDrive.update()

            # Warn on no file
            else:
                print(' ! No file in "{}"'.format(voice))

        dic.unmount()

    elif args['mp3']:

        mp3Player = Mp3Player()

        if args['load']:
            if args['audiobook']:

                sdCard = SdCard()

                # Get glob files .aax
                aaxFiles = Fs.findFiles(
                    sdCard.mountPath, '*.aax'
                )

                # Process every aax file
                for aaxFile in aaxFiles:

                    aax = AAX(aaxFile)
                    aaxOutputFile = aax.getOutputFile(fileExt='mp3')

                    if 'y' == raw_input(' ? Process "{}: {}" (y/n):'.format(aax.author, aax.title)):
                        tmpPath_aax = pathJoin('/tmp', aaxOutputFile)

                        aax.to_mp3(tmpPath_aax)

                        GDrive.saveAudioBook(tmpPath_aax)
                        mp3Player.saveMusic(tmpPath_aax)

                        Fs.mvToTrash(tmpPath_aax)

                sdCard.unmount()
        mp3Player.unmount()

    elif args['drive']:
        if args['update']:
            GDrive.update()
